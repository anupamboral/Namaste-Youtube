//*Notes

//* So when we go to give a interview and it is a machine coding round then with the interviewer we have to first discuss some important things the first thing is requirement clarification so basically we will be asking what are the features we are going to build just say like for example we are building a youtube like application so UT is nota very small application it has so many features to build that is why we will first clarify that what are the requirements and what are the features we are gonna develop then next we will discuss that what are the Text Stack we'll be using so just like we will use redux for state management and for everything you choose you should know a justification that why are you choosing that specific technology like here we are choosing redux because we are going to deal with a lot of data so if it was a small application then it would be great if we could use context api for state management but as it will bea very data heavy application that's why we will use the redux library as a state management library then next for styling purposes we will be using tailwind css and do not for get to justify why we are choosing it so we will choose tailwind ceases as it will make our development process so much faster because it offers classes which will help us to develop the styling of the any component so much faster and then for routing we will using react router dom and then for bundling we will be using parcel and every time you choose something you should justify why you are using it so we already know parcel has hmr or some hot module replacement and many other features which we can see in parcel's website so basically it is a very good bundle rbut before giving the interview you should know in detail that what are the justifications you will be using to justify YRU choosing that specific technology and then for testing purpose we will use react testing library and Jest. And to discuss this tech stack You should not take more than 5 minutes and also the requirement clarifications may take 5 to 10 minutes. Now usually when you are choosing any text stack the interviewers are not that rigid that they will say you should choose another technology that usually not happens but in some special cases it may happen that they can say you have to use normal css , you should be ready for that also but usually it does not happen.

//*Now after you have discussed the features after you have discussed the tech stack, now  you have to spend the next 5 minutes in planning, don't start writing code, right now see "discussing text stack discussing how your app will work tailwind and all that stuff comes into high level design" , "low level design comes in that how do you structure your components, how will you use your ui and data layer together and a lot of other things".

//* see image - Project Planning.png
//* That is known as low level design so you will have to focus 5 minutes on that , so  I have also seen youtube app why am I discussing the same with interviewer why am I discussing the same within the interviewer ,because you will be on the same page with interviewer ,you can build youtube with thousands of different ways , you can build youtube in thousands of different ways, you will discuss your approach with that and you will be on the same page.
//*So with a normal drawing, so I would say , Akshay so when I will develop my youtube app, my youtube app will obviously have a header , like we have in our youtube app and what else I will develop, I will develop a header and this header will have a menu , which is  to open the side panel .
//* so here in the left, I will have a side panel what comes inside my side panel side panel consists of some links like subscriptions,library and some other stuff , if you click on that  menu icon , it just collapses when you click the menu btn and if you click again then it will expand, and it just comes out I will develop this feature,then comes our youtube logo beside the menu icon, so we will have a youtube logo ,and after logo our search bar will be present, and then beside that we have our user icon after the search bar., then  we will have our body in the middle, what does this body contain? videos(video components), but we have some topic filter  buttons ,these are button list kind of , we will have some filter buttons and then below buttons we will have our main videos which will render over here right so we will build like this  and suppose if I click on a video it will open a new video page .
//*   And then we will also discuss that if I click on the video it will take me to a new page,which is known as watch page,it is known as /watch/videoName in the url when we click on any video , let us go back to our design ,you can say when we will open /watch by clicking on any video, so it will open a watch page it will have the same header, it will have a video playing in the left, it will have some video suggestions in the right and it will have a comment section .
//* Does that make sense this will be a video playing over here got it does that make sense this is how you have to discuss I think this is good enough let us let us try to build at least this much.

//* While planning we will also have to spend 5 more minutes to discuss how we will differentiate the components so basically what will be the components we will be creating so first of all we will create a header component then in the side we will create a sidebar component and it will be in the left side and then in the right side our body component will exist and inside the body component at the top position there will be a button list component and below the button list component there will be a video container component.

//* Now in the previous project we installed every package from scratch but in this project as we are doing it as a machine coding round so we are not going to instal every package one by one because time is very limited for this kind of coding rounds so it does not make any sense to instal every package one by one we should prefer that for big projects but for now we will use create react app package which will automatically instal all of the necessary package swe will need to build a project so let us run the command.
// //*npx create-react-app namaste-youtube
//* Remember in npx is used for running or executing any package and create react app is a package and we are executing it using npx.
//* and now just run the script - npm start  ............ to run the live server
//* That will help us know more about creating the appwe do not need parcel here we already have web pack setup along with this right we already have the path along this so if we see it has created folder structure for us it has already created an intense dot js it has already created app.js for us it is loaded this appright so now it might have some formula no more few things right it has set up testing also for you if you will go to Pathways Dot Json you would find that it already has testing library for you
//* inside the src folder there is a reportWebVitals.js file , what's a work of it?
/*By default, Create React App includes a performance relayer that allows you to measure and analyze the performance of your application using different metrics.

To measure any of the supported metrics, you only need to pass a function into the reportWebVitals function in index.js:
//*example
reportWebVitals(console.log);
This function is fired when the final values for any of the metrics have finished calculating on the page. You can use it to log any of the results to the console or send to a particular endpoint.*/
//* inside index.js <App/> is wrapped inside <React.StrictMode> component , but what is this <React.StrictMode> component?
//* <StrictMode> lets you find common bugs in your components early during development.
//* Know for styling we will again use tailwind css so lets instal it asa dev dependency using the command - npm i -D tailwindcss and create the configuration of it by running the command : - npx  tailwindcss init
//* it will Initialize tailwind css in our project and create the configuration file
//* now we need to Configure your template paths inside the config file of tailwindcss to tell tailwindcss in which files we want to use it. so we just need to set the content property's value to "./src/**/*.{html,js}".

//* Twitterpilgrim.conflict.cssconflict.js right what do we config over here do you remembernow we will tell our tailwind what files to track we will tell our tailwind what files to track remember we wrote something over here what what file should I trackall the files inside my srcwhich has an extension ofwhich has an extension of jshtmlplease track all these fileswe can just write Js also because all the files are javascript files not we don't have a html file right does that mean does that make sensewe have configured this upcool so now we have done that now what we have to do now we will write all our css inside our GS5 but what css do we write inside our css file now I don't need any of it but I will need few things inside index .css or app dot css over here what those three lines do you remember what were those three lineswe will be doing at the red tailwind what will be installed based first of all and then we will instalwhat components is it not components what was the third thingutilities exactly you people are amazing you people remember everything right so our css file will only have these three rights and we will not touch this css file forever now.
//* now we need to Add the Tailwind directives to our index.css file . so we can remove all of the pre-written css and then add these three lines:-
/*@tailwind base;
@tailwind components;
@tailwind utilities;*/
//* And as we are using create react app so there is no need to add the post css,because it is already installed by our create react app.

/* our decided  components
 * Head
 * Body
 *   SideBar
 *     MenuItems
 * Main Container
 *   ButtonList
 *   VideoContainer
 *      VideoCard*/
//* so now let's create our Head component, so inside our src folder we will create a components folder and then inside it we will create a Head.js file. and now inside this file, till now we used to write it from scratch but now we should learn a shortcut for creating a component, inside the Head.js file if we just write `rafce` then click enter then we will get a boilerplate of the component. So when we are giving interview then to save time we can use this shortcut.
//* 'rafce' stands for react arrow function export component. it create a boilerplate component using arrow function and export it by default.
//* there is another shortcut "rafc" which stands for "react arrow function component" it also creates a boilerplate component using arrow function but it does not create the export statement.
//* So now we already created our head component so now lets create the other components we will have now below the head component we will have our body component and inside the body component in the left side there will be a sidebar component so let us create the body and the sidebar component, And we will import the sidebar component inside the body component and we will also import the body component here in app.js and put it below the head component.
//* Now inside the body component at the right side there will be a main container component and inside this main container at the top we will have a button list component and below the button list component we will have a video container component so first of all we will create our main container and import it inside the body component and align the sidebar component and main container component side by side using tailwind css and now inside the main container first we will have a button list so now we will create a button list component and import it inside the video container component and then we will also create a video container component and put it below the button list component. we are just structuring our components by building the skeleton.
//* So lets build our head component so first of all inside the head component we will hav ea menu icon and beside the menu icon we will have a youtube logo so we will put these two inside one division so this will be our first division then in the middle we will have a search barS a search input and a surge button so our second division will be for these two and at the last we will have our user icon and for giving every division it is required space we will use grid this times oit will help us to give different amount of portions to different divisions so basically when we use grid then we can divide the whole width into12 portions and whatever part of the 12th portion we can mention that in every division because for the first division which contains the logo and the menu icon we will need a small portion like one portion of 12th and the search bar requires a bit more space S we will give it10th portion or 9th portion and at last the user I cancan be adjusted inside one portion. to do it we have mention grid and grid-flow-col property in the parent div and in the child div we have to mention col-span-1 property if we want to give any div only one portion.
//* So now lets create the sidebar component so inside the sidebar component we will create some unordered list and here we will put all of them enu options like home shorts videos subscriptions and many others.
//* Now after creating all of the menu items of the sidebar so now we want to build a functionality to basically collapse and expand the sidebar on the click off menu button but one problem is the menu button exists on the head component and the sidebar is inside the body component so basically two different component sand to implement this functionality we would need a state variable which will keep track if the sidebar is expanded or collapsed but if we want to just use a normal U state hook in that case we have to lift the state up and basically put the state variable in the app component because they are only the head and body component both exist so rather than putting the state variable in the app component it would be very much better if we have a global state space ,Because from this global space any component can access  the data as necessary.
//* Now to create the global space to keep the data we will create a redux store so we have used also in the previous project and we will also use it hereSo now to use Redux we have to install Two dependencies one is redux toolkit and second one is react-redux.
//* command - npm install @reduxjs/toolkit , npm install react-redux
//* Now we will create our Redux store so its time to create our details folder inside our src folder and inside the utils folder we will create our store and we will name it store.js and inside it we will import a function from redux toolkit named configureStore . So it is a function and inside it we have to pass our object and inside this object we have to mention the reducer Object so it is the main reducer object which will contain all of the reducer Of the slices.
//* And now we will create the slice which we will name appSlice.js inside the utils folder and in this file appslices.js first we will import create slice function from Redux Toolkit and then after that we will create a constant and name it app slice and then its value will be create slice function call and inside the function call we will create an object and its first property will be the name and the name will be again appSlice, And then the next property will be initial state so here we have to mention that what will be the initial state of the side bar , As by default it will be open so the initial state will be isOpen=true ; And then we will create the next property which will be reducers and inside this object so reducers is basically an object and inside it we write all of the actions we need so inside it we will write our first action named "toggleMenu"; And inside this toggle menu has a property we will mention the state because to access the state so basically the initial state inside this action we have to mention it as a property, And then inside the arrow function we will write the condition that whatever the current value of the isOpen property just set its value to its opposite so basically we will use the not! operator. like this:-
/*const appSlice = createSlice({
  name: "appSlice",
  initialState: {
    isNavOpen: true,
  },
  reducers: {
    toggleMenu: (state) => {
      state.isNavOpen = !state.isNavOpen;
    },
  },
});
export const { toggleMenu } = appSlice.actions;
export default appSlice.reducer;*/
//* And then after exporting the action and the reducer now we have to go inside the store we created and there we have to import this slice and mention it inside the reducer of the store.like this://*const store = configureStore({
/* const store = configureStore({
  reducer: {
    app: appSlice,
  },
});*/
//*And now we need to import this store inside our app js and then from react redux we have to import the provider component and wrap our head and body component inside the provider   as an attribute of the provider component we have to mention the store attribute and its value will be our redux store from store.js which we created.
//* Love sometimes it becomes necessary to cheque if our deduct tool is perfectly set up or not so is it working or not and to cheque it the easiest way is we can see it in our redux dev tools extension we installed earlier so if we click on that extension we will see that inside the app, the initial state , isNavOpen: true is showing, it means that it is working properly.
//*1.24.25
//* Now let's go to our head component now we will try to implement the functionality of collapsing and expanding the sidebar on click of the menu button or basically the menu icon on the top left corner and while implementing this functionality we should explain every line to the interviewer so first of all to implement this functionality we will attach a onclick handler on the menu icon and inside it we will write a callback function and inside that callback function we willMention our dispatcher function which we will create now so we will name it toggleMenuHandler function now let us create this struggle dispatch function so above the head component we will create a constant and basically this constant is for this toggle MenuHandler function and inside this function. An inside this function we will dispatch a action to toggle the menu and to dispatch the action first of all we need to import use dispatch hook from react redux and after importing it we have to save its value inside a constant and we will name that dispatch now this dispatch is basically the function which will help us to dispatch the action so now inside the toggle menu handler function we will call this dispatch action and inside it we will pass toggleMenu action which we created inside our redux slice so first we need to import this action and then inside the dispatch function we will call this action like a function call and we need to pass any arguments inside it because here ,there is no payload to pass. So now here our work of changing the data in our store is finished but the next work is to basically subscribe to our store so that sidebar component should be subscribed to the store so whenever the state changes inside the redux store depending on that our sidebar should collapse or expand.
//* Now we have to go inside our sidebar component, And here from this component we need to subscribe to the slice of the store so that particular part where we created our toggle menu action and we remember that to subscribe we need a   let's import the use selector hook from react redux so we can subscribe to the store, And now after importing the use selector hook we will create a constant named isOpen And its value will be use selector hook call and inside this use selector function we have to specifically mention that which part of the store we want to subscribe so here we have to mention the   will change basically the state we mentioned inside the initial state property while creating the slice and its name was isMenuOpen. And now using the constant name isOpen we can write early return statement so basically if its value is false then return null so then it will return earlier and no side bar will be displayed because the below code will not be read by the compiler because remember whenever the return statement comes after that the execution stops so basically we will write a condition that if its value is false then return null and if it is true then return the sidebar component and that is how it will work.
//* So we have to explain the interviewer that when we are clicking on the menu button it is dispatching And action and that action is calling the reducer function and that reducer  function make changes on the slice of the store,On the other hand as the sidebar is subscribed to the store through the selector that's why it will automatically change accounting to the slices data.
//* Now it's time to create our main container so inside the main container,  The first component is the button list component so what is a button list so it is a list of button components so there will be so many buttons components inside this buttonLists component.So first of all lets create a button component which we will render inside the buttonLists component.
//* Now as we know that we will render  button component inside the button list component  there will be multiple buttons that means can pass a prop Inside the button component and when composition it inside the butter list component  using that prop will render the button text basically we will receive the prop inside the button component  make the text of the button  inside the butter list component we will make an array of  of the text want as buttons  we will map it iterate the array  in every iteration we will pass it as a prop ide the button component lets do it.

//* ⁡⁣⁢⁣Finding Youtube Api⁡
//* Now as our button list container is working fine now it's the time to To build the video container and inside the video container obviously we will have all of the youtube videos but from where we will get those videos so obviously we are on a use again the live api of youtube and the good news ist hat we don't need to face the Cors policy this time, Because youtube gives us api and api key To build things but Swiggy doesn't give the api key that's why we needed to get it from the network tab of developer console but in this time we don't need to do that so to get the youtube api We just need to search "⁡⁣⁢⁣youtube videos list api⁡".
//* ⁡⁣⁢⁣creating credentials/Api Key and Enabling youtube api usage⁡
//* After searching we'll have to click on the first link and after opening the page of the website we will see there is a table and inside that many kind of Apis are mentioned for getting one video and getting multiple videos and there is also option for getting the popular videos so for now we will click on the option for getting popular videos and after clicking a page will open and from there we have to click the http link so there will be many options but we have to click on http to get the http link and we need to copy it and now we have to use it inside our project for calling the api and as this api data will be the hard coded data so we will create a config.js file inside our utils folder.
//* Now inside the config file we will create a constant we will name it youtube video key and its value will be the api  we copied From YOUTUBE VIDEO  LIST API PAGE. And now is she if we clearly cheque out the api In the last portion of the api we will see that there is a place for api key and here we have to mention our api key but from where we will get our api key so youtube also offers free api key but it is limited so it has some restrictions for using like for some time you can use it but for a project using it is fine so to get our api key again we have to search "youtube api key auth".
//* Then we have to click on the first link and a page will open inside that page we will see a option for opening the credentials page we have to click on that and after clicking it will take us to a page which is basically the credentials page- "https://console.cloud.google.com/apis/credentials".
//* Now inside this page we have to create our credentials so basically Our personalized api key and to create our credentials we have to click on the create credentials option and then choose api key as we are going to use it for api key and after clicking it will show us our personalized api key we just need to copy it and come back to our config file and then above the api link we will paste this api key so basically we will create again a constant and we will name it api key and its value will be the api key we copy it from the website and then we will just concatenate this api key with the api link and then we will export the api link and we don't need to export the api key as we have already concatenated the Api key with the api link already.
//* And now let's go inside our video container Component and inside that so inside the VideoContainer component Before the return statement we will create a use effect hookas we know that we make the api equal inside the use effect hook and as we just need to call the api once in the initial render that is why we also have to mention the empty array as the second parameter of useEffect hook.And using the fetch function we will get the data and then from that we will get the Json Print it in the console to see that if it is working fine or not so if the data is coming from the api or not.
//* And in the credentials page in the sideward the top option will be for enabling the usage of youtube apis so if its our first time for using youtube api then we have to go to this option and enable the usage of youtube api for our account unless it will throw an error.
//* And now we got our api data in the console now it's time to build our video container so inside the video container there will be multiple video cards so first of all let us build our video card component.
//* Now after building the video card component it is time to get the data inside the video card component so as there will be multiple video card components that is why we will pass the data as prop inside the video card component from the video container component so we will come back to the video container component and as we got the data so let's create a state variable using useState hook To put the data inside it when the data arrives from the server and we are using the use state hook because it will trigger the react reconciliation algorithm so we already know about it that whenever the state variable changes it will trigger the reconciliation algorithm and the algorithm check the new data arrived so basically the changes in the component and it immediately updates the component that is why we will use the useState hook to save the data.
//* Now after saving the data inside the state variable we will import the video card component here inside the video container component and we will composition one video card component and pass the data of one component only so basically from the array we will pass only one object which will contain the data of only 1 video and initially we will not render the all of the video card components because it is the key principle to build only one component first then only composition multiple after completing one component so we will first not map the videos array instead we will just build one component and after perfecting it then we will only render multiple video components so as the prop we will pass the data and we will also pass the key and inside the data the id is already exist so we will use that for key and after doing that we will receive the prop inside the video card componentWe will use that data for building the video card component.
//*⁡⁣⁢⁣Using the parameters  of the api⁡
//* So right now we are getting only5 results but in the data api page they mentioned a parameter named Max results so we can use that and set its value to 50 like maxResults=50; To get 50 results so we can get maximum 50 results as they mentioned in the website so let us implement this as our videoCard component is ready. And also the region value to India to get the videos related to India so it's by default set to us but we have to set it to India like region=IN;

//* So whenever we click on a video cardinside the youtube pageit will take us to a watch pagewhere we can see the videoand it is time to implement this feature inside our appThiswe have to importreact Router Domso let us instal itusing the command npm i react-router-dom.
//* We installed it for setting up the routing configurationas we have to now navigate to the other pages ofour app so for routingwe installed itand one more thing we have to notice is thatwhenever we go to thewatch pagethe headcomponent and the sidebar componentstays theresothey does not disappear when we open the watch pageso that means thatthese two components will keep intactso first of all let us create our routing configuration inside our app.js file by importing createBrowserRouter() function from react router dom.

//* ⁡⁣⁢⁣difference from previous project (routing config)⁡
//* ⁡⁢⁣⁣In the previous project of Namaste React we made our app layout component which contains all of the head and body we made that component as the main parent element of the router configuration and we did that because when we go to another page of that app then already the body component will change so there the outlet component will siting the place of body so then we can treat the body component as the child and whenever any pages changes then the body component changes and that component appears that's why we put the whole component inside the router configuration but in this app the scenario is different so here the header will appear for all of the pages but the whole body container will not change the sidebar will be still there and only the right side main container will change and the watch page will appear so that is why the outlet component should be placed inside the body component where the main container component is placed because in this scenario only the main container will change with the watch page container which we will create that's why the outlet component will sit inside the body component in the place of main container and main container will become the child of body component so here we will make the body component as the parent element of router configuration and the outlet component will be used inside the body component where the main container is placed and now the main container and the watch page which we will create both will become the child component of body so here the placement of outlet component is different that is why it is different from the previous app so we have to be mindful to place the outlet component and also which component we are selecting for the parent element of the routing configuration because in this case the body should be the parent of routing configuration but in the previous app the whole app layout was the parent element of routing configuration.
//* Now after setting up the router configuration and placing the outlet component in the place of main component we also have to provide the router using router provider component and we have to place it at the place of body component because this router provider component willTreat the body component as the parent component and for the slash it will show up the body component by default so instead of the body component we have to place this router provider and as the attribute we have to mention router value to appRouter which we created.
//* And now after setting up the router configuration and creating a basicwatch page component now we have to put our video card inside a link component and mention the two attributes value of link component to " <Link to={"/watch?v=" + video.id}>". So then whenever we'll click on any video card then it will take us to the watch page as we have already set up the router configuration. and at last after after /watch we written ?v=" + video.id}, it is called query parameters, this will also added with the url when the user will click on the any video card
//* why we passed the video.id with the url as query parameter?
//* because inside the watchPage container we will read the video id from the url.
//* closing side bar whenever watch page loads
//* Now one more feature about youtube is whenever we click on a video card it take us to the watch page but immediately the sidebar will collapse automatically so side word will be there but it will be collapsed and to build this feature we will dispatch action from watch page component and we will do it inside the use effect hook so whenever the page loads immediately it will collapse the sidebar now we already have a toggle menu action,Which we created inside the slice but right now we do not want to toggle the menu instead we just want to close every time we open any video card basically open the watch page so let's build a action where we will set the initial state to false which will basically every time collapse the sidebar whenever we will open our watch page component by clicking on any video card so lets go to our app slice and create a close menu action and then we will also export it and then we will import it inside the watch base component and we will also use the use dispatch function which we need to dispatch an action and using both of these so basically the dispatch function and also the action we created and we named it close menu using this wew ill dispatch the action of closing the menu whenever the Watch page component loads.
//* ⁡⁣⁢⁣using useSearchParams Hook⁡
//* Now inside the watch page we have to get the patterns basically the parameters which includes the video id we need it to search the video details so previously we used useParam() Hook to get the paramsBut this time it will not work because it is not separated with / Basically the parameters are not separated with this slash sign That's why if we use this hook it will return nothing and it will not work so instead we have to use another hook which is named useSearchParams() hook. So we have to import it and save its value inside a constant and then on that constant we can call a method .get("v") , Inside the gate may thought we have to mention the query key so basically using which K we want to search inside the param, And in this case the key was "v". So we will search the video id using these use search param hook.like below:-
/*const [params] = useSearchParams();
  console.log(params.get("v"));*/

//* Debouncing
/*In JavaScript, debouncing is commonly used to enhance browser performance by ensuring that expensive operations (like complex calculations, API calls, or DOM updates) are executed only when necessary. JavaScript operates in a single-threaded environment, meaning it can only handle one operation at a time. When certain actions are triggered too frequently, such as during continuous scrolling or typing for searching which is making an api call, it can overload the browser and cause sluggish performance.

Approach
The button is linked to an event listener that invokes the debounce function when the button is clicked.
The debounce function takes two parameters: a function to be debounced and a delay in milliseconds.
Inside the debounce function, a variable named debounceTimer is declared. This variable is crucial for executing the debounced function after a specified delay.
When the button is clicked, the debounce function is called. If the button is clicked only once, the debounced function is scheduled to run after the specified delay.
If the button is clicked again before the end of the delay, the initial delay is canceled using clearTimeout(debounceTimer).
A new delay timer is initiated, effectively resetting the debounce process. This mechanism ensures that the debounced function is only executed after the user stops clicking the button for the specified delay duration.
The core idea behind debouncing is to start with a timeout of 0.
If the debounced function is called again within the delay period, the timer is reset to the specified delay.
Ultimately, when the timeout occurs, the debounced function is executed. The process repeats for each call to the debounce function, effectively resetting the timer and introducing a delay for each invocation.*/

//* So Debouncing is for stop executing unnecessary function calls frequently so using it we add a delay time for executing any function like making a Api call,or  a scroll event or any complex calculation.
//* Select understand it using an example let's say we're searching iphone 6 Pro maxi n Flipkart's website and we know that Flipkart shows suggestions as we type something on the search barSto show the suggestions flipkart makes api call to get that suggestion which will be displayed to the user we may think that on each keystroke so after typing each letter the browser is making an api call to show the suggestions but that's not the actual case so if we go to the network tab and then search something on the flipkart website like iphone 16 pro maxSo it has 17 letters including the spaces but if we type it first we will see that the browser has only made around six to seven api calls but if we type it slowly we will see that it has made more api calls like 11 or 12so it is doing it because of the debouncing thing concept so debouncing adds waiting time for a function execution and if the function is triggered again before the end of the time then the time count will be reset from start, So lets say Flipkart has a debouncing time of 200 milliseconds so while typing iphone if the user do a keystroke and and he does the next keystroke before finishing the 200 milliseconds then the browser will again start the timer and only when the timer will be finished and the user has not typed anything before finishing the timer only then it will make the api call so that is why even after the sentence had 17 letters but the browser had made only 6 to 8 api calls when we typed it first because before finishing the timer we typed another letter that's why the function execution was cancelled but why we want to decrease the number of api calls so let us also understand it using another example so let us say thousands users are usingFlipkart's website and they are searching for the same thing which is iphone 16 pro max , So without the Debouncing all of the browsers Had to make 17000 api calls For only 1000 users but after applying debouncing concept the browsers had to only make 6 or 7API calls Average for all users so the total numbers of api calls will be 6000 to 7000, So it was an example for 1000 people but this kind of websites gets lacks of users and they usually search so many inputs and this debouncing concept can make so much performance difference because oft his delay timing of function execution. Usually we do this kind of function calls like api calls for suggestion is for better user experience but we also do not want bad performance because of so much unnecessary function calls that's why to limit unnecessary function executions we use debouncing.

//* So let's implement the functionality of debouncing in our searching feature before that we have to copy the youtube searching api and paste it in our config file because we needed to make the api call and then we have to go to our head.js file because there we have put our input element of search so first of all we have to keep track what the user is typing and for that we will create a state variable and as usual we will name it searchQuery and the second set functions name will be setSearchQuery so this is for updating the state variable now we have to use it so we have to go to our input element of the search and there we have to mention the value attribute and its value will be search query variable so the state variable we created and we will also have to mention another attribute which is for updating the state variable data when the user is typing something inside the input element so we have to mention the on change event attribute and its value will be a callback function and inside it we have to receive the event as the parameter of that callback function and then inside the callback function we will call our set search query function and inside it we have to pass the argument to update the value of the state variable so inside the function we will pass event.target.value. It will basically update the state variable whenever the user will type something and now we can console log our state variables value to see it if it is working properly.
//* now as we have the input the user is typing, inside state variable searchQuery. now using it we can make our api call from youtube search suggestion api.
//* as usual we will make our api call inside useEffect hook, and now this time we will mention searchQuery state variable inside the dependency array of useEffect hook as want to make the api call every time state Variable changes , so when the user will do new key press(add any new letter) we will make an api call but if the user press a key before 200 milliseconds then we will decline the api call as we want to use debouncing for optimization for not making unnecessary api calls.
/*
⁡⁣⁢⁣ useEffect(() => {
    //*making apn api call on each key press
    //* but if the difference between two api more than 200 milliseconds
    //* decline the api call(debouncing)
    ⁡⁢⁣⁣const timer = setTimeout(() => getSearchQuery(), 200);⁡ ⁡⁣⁢⁣//* setting a timer of 200ms for making the api call.

    //* To decline the api call will use the return function which used as a cleanup function, and this clean up return function will be only called when the current component will be unmounted/trashed.
    //* suppose user is trying to type "iphone", he pressed first i
    //* so our useEffect will be called and the timer of 200ms will start and after 200ms it will male the make api call.
    //* but before 200ms if the user press "p", our state variable will update and immediately it will trigger the reconciliation process, so this process will unmount/trashed the current component and update it a new refreshed component.
    //* will unmounting our return cleanup function will be called and there we will clear our timeout,
    //*  then our new component will be mounted and it will again start a new timer of 200s.⁡
  ⁡⁢⁣⁣}, [searchQuery])⁡;⁡*/
//* So when we are searching something now our suggestions are displaying on the ui but when we focusout from the input box so when we click outside of the input box then the suggestions should not be displayed so that is why we will create another state variable named showSuggestions and its initial value will be false because initially we do not want to show the suggestions and then in the input box we will use a event which is named as on focus event so basically when we will click inside the input box this event will be triggered and then we will make the state variables value to true which will display the suggestions and then we will also use another event named on blur so this event basically is for hiding our suggestions so when we are not focusing on the input box so clicking out of the input box then this event will be triggered and inside this event we will set the suggestions state variable value to false again that will eventually hide the suggestions box.

//* ⁡⁣⁢⁣𝘂𝘀𝗲𝗡𝗮𝘃𝗶𝗴𝗮𝘁𝗲() 𝗵𝗼𝗼𝗸 𝗳𝗿𝗼𝗺 𝗿𝗲𝗮𝗰𝘁 𝗿𝗼𝘂𝘁𝗲𝗿 𝗱𝗼𝗺⁡
/*This hook allows the programmer to navigate the user to a new page without the user interacting.

For normal navigation, it's best to use Link or NavLink. They provide a better default user experience like keyboard events, accessibility labeling, "open in new window", right click context menus, etc.

Reserve usage of useNavigate to situations where the user is not interacting but you need to navigate, for example:

After a form submission completes
Logging them out after inactivity
Timed UIs like quizzes, etc.*/
//* ⁡⁣⁢⁣usage of this hook for our searching functionality⁡
//*⁡⁣⁢⁣const navigate = useNavigate();⁡ //*This hook allows the programmer to navigate the user to a new page without the user interacting. we will use this hook to navigate the user to search results page when he search something on te search bar, because here we can't use Link component when onClick event or onSubmit Event occurs. check documentation for more info.
/*         <input
            onKeyDown={(e) =>
              e.key === "Enter" &&
              navigate("/results?search_query=" + searchQuery)
            }
          />

          <button onClick={() => navigate("/results?search_query=" + searchQuery)}>
            🔍
          </button>*/

//*when we search something on the searchbar the useNavigate component take us to this searchResults page when we search something in the searchbar from another route like home page or channel page and it will trigger the useEffect hook to trigger the api call,  but when we are already on the search results page , and search anything second time and click enter then it will change the url route but as the page is already rendered so it will not call the useEffect hooks if we don't mention anything in the dependency array that's why we have to mention the query we get from the url in the dependency array to call the useEffect hook whenever the user search something.

//*⁡⁣⁢⁣Building live chat feature

//*  what are the challenges of live chat?
// //*1. get data liveright
// //*2. how do you update the data on the page ,update the ui
//* if we open a live video in youtube, what is happening in this live chat? how are these comments being shown up? what this comment at the end of the day ?
// //*this comment is a div , when a new comment is coming up, what is happening?
// //*the page is getting appended by the divi at the end of the day a new div, is getting appended , now there are 23,000 people watching this stream and every second there are so many people commenting , so if I keep putting in div into my html don't you think my page will become slow,why will it become slow because the Page size will increase, suppose if I if I see this live is going on since 10-20 minutes but is page not freezing, if I leave it open for one hour it will not freeze
// //*this is what the complexity of a live streaming application
//* we have to update ui in a efficient way ,and you have to also give a better experience for a user right
//*so there are 2 major challenges ,1st challenge on a ui layer is to update my page in such a way that my page does not freeze even if I open my page for 1 hour -  2 hour and there are millions of comment coming in, my page will handle it, second most complex thing is in the 2nd layer, data layer,  how do you get data display it onto the page
// //*if you understand this then you can develop a lot of big applications ok so let's talk about it first of all let's talk about data that \ how can I handle data of this application?
//*see if it is not live , what happens we can just call an api you know use effect that our job is done easy peasy ,but now we are talking about live data which needs to update .
//* Data layer
// //* ⁡⁢⁣⁣So there are two ways we can handle live data⁡
//*⁡⁣⁢⁣the 1st way is using websockets⁡(see live-data.png image)
// //*websockets is a two way connection established , it's kind of like a handshake between a server and a ui listen , so what happens if this is if this is your ui if this is your ui this is your this is your  server what happens is it is a handshake, it creates a handshake and what happens in it is once you have connected a hand shake, now what happens is you can quickly send data from either sides(both sides),it's a bidirectional connection , you can send data to server through ui  and from server back into ui and it is a connection which is started as soon as you open the application a websocket connection is established, now you can send data immediately you can send data from both sides,in websocket connection in websocket connection there is no interval(no time gape),so when connection is established is no regular interval,the data can come in right now. initial connection takes a little time so once the connection is set up it is like a handshake  then we make a handshake that ok two servers are connected now it is very easy once the connection is established now you can send data from any direction and can send data wherever you want
//*⁡⁣⁢⁣the 2nd option is long pooling/api pooling⁡
//*what do you mean by api polling?  ui requests server, data flows from server to ui, its 1 directional and after an interval, in websocket connection there is no interval , the data can come in right now ,in api pooling there is interval,  the 1st set of data came in at 1st millisecond, the second set of data coming 20 milliseconds later, third set of data might come in after 10 minutes,so we understand both of them ,in websocket connection 2 servers connect to each other now they can send data anytime they want to,lets talk about it 2nd is api polling what does api polling means the data is "unidirectional", suppose this is my ui this is my server, so ui will keep polling data after 1 second or after 10 seconds,  this is known as api pooling

//*⁡⁣⁢⁣𝗘𝘅𝗮𝗺𝗽𝗹𝗲 𝗼𝗳 𝗴𝗺𝗮𝗶𝗹⁡
// *now we will talk about applications and you will realise that where does it fall ,  an example so what about Gmail ,a Gmail or websocket or Gmail or polling? we do not know what Gmail is whether it is websocket or polling but lets think about where does it fall .You have to ask a few questions to yourself ,so do you need the email very real time that okay by the moment I got the email the moment I sent the email the moment I should receive to the other person , no right, if I get my email after 10 seconds its fine right , so what I will do is when I build a Gmail app I will check after every 10 seconds that whether a new email has come in or not , my ui can make api call after 10 seconds I can make a call to packet and cheque are there new emails,so instead of establishing a connection, so you know in what happens in web circuit you establish a connection and it just stays there right and then websocket connection is heavy , so you don't need a websocket connection because you just don't need like very instant data,  so you can do api polling in an application like Gmail , so where does email call,it falls in api polling

//*⁡⁣⁢⁣Example of ⁡⁣⁢⁣zerodha⁡
// *  let us talk about another application suppose if there is an application like zerodha an application where there is stock market ,what do you need over there, if there is a live trading platform where every millisecond you need to be very very close to real time ,gmail does not need to be real time , but when you need to be very real time that you precisely need every  millisecond you need that graph to go up and down because while trading markets things can change within milliseconds your stock can go up and down within milliseconds , type critical applications, your crypto currency, trading all that stuff is built using websockets , so your stock market apps and all that stuff like IND money

//*⁡⁣⁢⁣Example of whatsapp⁡
// *
//* Let's talk about Whatsapp what happens in Whatsapp can you do api pooling in Whatsapp? that after 10 seconds I will get a chunk of messages if there is a new message you know why because it is time critical it is very time critical it should be near real time why ? because suppose if you are texting very fast right so what can happen is suppose I sent the message and you also sent me the message the order can change and if the order of your chat changes you know what blunder it make .it can wake a lot of blunders in the chat in a live chat application you always need to have web sockets

// *⁡⁣⁢⁣Example of cricbuzz⁡
// * what would cricbuzz do ,lets go to cricbuzz live commentary cricbuzz ,in the console, it is loading the commentary ,this is api polling , amazing it is loading the commentary ,fetching data of first api call started at 0.71 milliseconds ok and let's see this second then started at 25 seconds do you see 25 seconds third was started at 50 seconds what is the interval ,do you see this started at 50 seconds, what is the interval , how that ui and data layer is working ,this is known as real engineering, in my system design round if somebody asked me a question about cricbuzz ,I will say I can do api polling after 25 seconds after every 25 seconds tell me why 25 seconds it is kind of aligning to how cricket works how cricket works , it does it is it cool or not before 25 seconds there will be no update about the next ball isn't it 25 seconds is the minimum time right kind of 25 seconds you cannot have to suppose even if a see even if a fast bowler is bowling out right see I don't want to  pole every five seconds also because its of no use right my  api calls will happen and there will be no  new data , 25 is a sweet spot suppose if a spinner is bowling right so sometimes in A match a spinner bowls very fast right a spinner bowls  spin just misses the ball right and then the wicket keeper gave gives to a spinner and then again the Spinner Bowls right so it is 25 seconds of sweet spot , we are  able to reverse engineer things up, we reverse engineered flipkart also like how the search is working we saw how youtube search is working we saw how cricbuzz is working now and I am showing it, tomorrow you go to any application see what is happening in your console, so in applications like crickbuzz we would need api polling right for applications like Cricbuzz we would need api polling
// *what if it was the same for soccer what if we have to build a commentary for soccer what if I have to build a commentary for soccer .let me tell you I will still do api polling I will still do api polling for maybe less seconds ,May be after every  5 to 10 seconds why because somebody needs to write it ,if there is a commentary somebody is writing it up and it needs time to build data right so every 2 seconds everyone 5sec nothing will change okay the commentary is not that fast ,like soccer ball pass  so the ball needs to kick in so that it can say that messy is passing the ball right something like that I don't know I have not seen a commentary written commentary for soccer I don't know even if it exists or not but I am just giving my thoughts out

// //* now with all that knowledge tell me what is comments of youtube built up on, Let me tell you it uses api polling it uses api polling , lets go to network tab lets see what's happening oh my god it is making see 3113 3114 15 18 oh my god people who think that api calls are expensive,what it is doing see the youtube number of calls that youtube makes ,have you ever thought that youtube would be doing this and think about this thing happening into the browser of just for this video just for this video it is happening for twenty thirty thousand 16,000 people watching in 16,000 people, my God and we feel that api calls are expensive, you understand the concepts you can write code very easily , in your life have you thought that youtube would be polling this data youtube is polling API calls literally making Api calls and getting data of the comments , now lets not talk about the backend engineering of how does it handle so many api calls do not worry about it let us focus upon the ui right so it makes api call to fetch data what is that api call let us try to find out see I can read it easily this is get live chat , what is the interval ,let's try to see the waterfall  so it is like 1.5 seconds every 1.5 second every 1000 and 500 millisecond you tube is making an api call ,think about in the world how many people would be watching live streams and it is making everyone 1.5 second those very calls from the ui ,think about lets forget about the packet load think about the complexity in the ui ,how much you suppose if I reduce even 1% of those network calls 1% how much can I save how much can I save,it makes a big difference,so why youtube is not doing after 5 seconds they couldn't do by after 5 seconds also right because they want to come up to a better user experience  and they want to look like real time but are these real time right so and one more thing
// //*when a lot of millions of people writing does that you know have you ever thought that why youtube does not show the time stamps, over here with the chat messages it does not show, it's a very tricky thing, it does not show because order does not matter ,in the live chat and we at the end of the day we think that ok Oh my god these people would be commenting in order ,these are things which you should understand even big applications do all these things we don't realize it it's like an illusion , you do not right because that's how the system design works ,staff engineers , when you become a SD1 SD2 SD3 tech lead then a senior software engineer then a senior software engineer then you become staff engineer those staff engineers they basically they they do this stuff the principal engineer there are chief data scientists and what not those people are the ones who put in their minds to give the best experience with the best tech and with the best optimized tech  so this is how applications are built now let us see what comes in the live chat.

//* ⁡⁣⁢⁣UI layer⁡
//*We have just talked about data layer we are yet to talk about ui layer, if we go to any live video page were live chat is going on in youtube, we can see the page is not exploding, it has made so many api calls and still the page is in place its not freezing up the page is intact in place , how is this happening ?  they are using api polling /long polling

//*  Why is this page not freezing ? some people may think it's because of fast laptop but no , not because of fast laptop ,because we have never realized that  what youtube quickly does is as soon as the messages increase from a certain number it quickly deletes it from your page ,it is cleaning up the mess from the page itself, how smart youtube is, we just don't realize it ,now you would be thinking ,I can go back and read ,see so many old messages ,but youtube is so clever that it removes the messages after a certain point like after 100 - 200 messages, it is removing those messages from the top so new comments are getting added from the bottom but gets deleted from the top ,so we can't realize that youtube is deleting the messages from the top portion, oh God we feel that youtube is pushing up data ,it is storing data till a lot of chats,no if it would keep on pushing things up in the dom what will happen?  we will explode our don we will increase the page size ,now youtube can also go even more clever that suppose if I am on a MacBook if suppose my browser version is latest suppose if my browser is chrome and not Internet explorer so it can change the number of item it keeps in the cache ,so that my browser does not freeze,  it make sense. how we can improve the ux,we people might go into youtube and we would also have to do system design, you would think about these things to give a best user experience ,you cannot say that youtube cannot say your browser is old, I don't want to support you are using a bad mobile phone don't support it, we will not support it, no, to give the best user experience youtube goes to a level where it configures different things for different different offsets, for different browsers.
//*so what I am saying is after a while youtube removes the messages on the top ,
//*  lets go back to the app to our app so in our youtube app  I want to build a chat , lets go back quickly watch page right this is our watch page here we had iframe here we had comments container so let us create two divs inside it right one division will have Iframe , and another division will have my live chat ok okso lets create a live chat component . live chat.js , let's make it look like a chat box similar to youtube chat box.
//* now our chat looks cool, now in our live chart we should have some comments or  chat message let's call it a chat message ok let's build a different component for chat message so we can build it in a new component ok
// * lets build a LiveChatMessage.js ,and after exporting it let's composition it inside our live chat.
//* Now after building our live chat message component we will composition it inside our live chat component because there will be multiple chat messages so first we will build one component properly and then we will usemap for iterating all of the chat messages to display all of the messages from this live chat component, Now we need some data to display so basically we will display image a name and chat message so basically what the user has written so for that we will need some random data so for random names we have got some data from over stack flow which is basically an array of names and a function randomly gives us a name from the array so we have created a new file inside our utils folder named helper .js and we have put that function inside that helper .js file and we named that generateRandomName(), So this will basically give us random names now we need some messages also so to get some random messages so some random sentences we will use a npm library named random messages so we can instal that library using the code
// //*import randomSentence from "random-sentence";
//* And now after installing it we have to go to our live chat component and there we have to import random sentence function from this library we just installed and now it is time to do api polling so we will not fix the data because we do not have any api to get this random data that is why we found two solutions one for generating random name and one for generating random text so now inside the use effect hook we will write the logic of api polling so to do api polling we will use the set interval functions o we already know that api polling is about making api calls after some intervals so that is why we are using set interval and after certain interval like two seconds or one secondWe will basically create a new object which will contain a new name and a new message and now to save this objects containing name and messages which are basically chat messages objects we will use our redux store so we will create a slice inside our utils folder named chat slice and as usual we will create the slice and inside it we will first add the name property then the initial state property and it is an object and inside it we will mention the messages properly because inside the state we will save all of the messages and this will be an empty array and now we will create our reducer sso inside it we will create our first action which will add the messages inside the array and in this time we will not use the push made 3rd because we do not want to push the objects from the last because push method pushes anything from the last so instead in this time we will use unshift method which will basically add the object in the front of the array and we are doing it because we want to show every new message appearing inside our chat list that's why we are using this unshift method and also we have to use flex column reverse so every new message will appear from the bottom first.
//* Now our chat slides is ready and we have to remember that we have to add this chat slice inside our store and we have to also export the action because while dispatching the action we have to use it now we have to come back to our live chat component and they are inside the set interval function we will call our dispatch function and inside it we will mention our add messages action and while calling this add messages function we will pass a object with two properties first is name and second is message now for the value of name we will use the random message generator function we added in our helper file and for messages we will use the random messages function we imported from the library we recently installed and we have to remember that we have to clear the effect that is why we have to use the written function inside the use effect hook which works as the clearing function and it is basically for garbage collection so that whenever our component gets unmounted All of the effects should be cleared out so inside it we will clear our set interval so our api polling is ready and we also dispatched the action which will add random names and messages inside our store slice, Now we have to subscribe to the store so we can show the data here inside our live chat component so we have to use the use selector hook and inside it we have to mention perfectly the location of the slice state , And now as a result it will give us the array filled with all of the random messages and names now we will use it to display all of the messages so basically using the map we will iterate it and using every object we will display the name and the message and after doing all of this our Live chat feature will fine,
//* ⁡⁣⁢⁣removing excessive messages so our page don't get freeze⁡
//* But there is still a problem which can freeze our bridge page, So if we keep adding elements to our dom then after a certain point the page size will increase so much and that will cause our page freeze, That's why to tackle this problem we can't make our array size so much larger that is why we can splice the array after a certain point in the addMessage action of chatSlice so when ever it crosses a certain number of chat messages automatically it will be spliced outlet us say we set it for 20 messages so whenever it will exceed 20 messages it will remove one in this way our page will not freeze ven after two hours.like this
/* ⁡⁣⁢⁣addMessage: (state, action) => {
      state.messages.splice(20, 1); ⁡⁢⁣⁣//* for removing messages after 20 messages so the dom will not explode because of excessive page size⁡

      ⁡⁣⁢⁣state.messages.unshift(action.payload); ⁡//* adding messages from front of the array⁡
    },*/

//* ⁡⁣⁢⁣adding own Live Message⁡
//*  Now in the real youtube application there is also a feature for adding Your own message inside  live chat, So we will also build this right now so first of all inside our live chat in the bottom portion we will add a input element and a submit button now we also want that when we click enter then it should be added inside the live chat for that we have to use the on submit event and to use on submit event we have to wrap this input element and the button element inside a form then it will work properly so we will put this input element and button element inside a form element and now after adding some styles to the elements now we will create a state variable named live chat message and it is basically a state variable where we keep track of what the user is typing inside the input box now after creating this state variable we will mention it as the value property of the input element and by default the state variables will be empty string, And now to change its value we will also mention the one change event inside the input element and then we will put a call back function inside it and then call our setLiveChatMessage function,And we will receive the event and pass e.target.value inside setLiveChatMessage function,So it will basically change the value of the state variable whenever the user writing something now we want that whenever the user clicks the submit button or press enter then the user retain input should be added inside the live chat box so on the form element we will add the onSubmit event listener,And inside it first of all we will prevent the default behavior because by default when the submit event occurs then the page gets refreshed so we will receive the event and first of all prevent this default behavior by calling the prevent default function on the event then next we will dispatch an action basically the add message action and inside it we will pass an object with our name and the message properties value will bethe user typed input so basically we already saved that input inside the state variable so we will mention the state variable here as the value of the message property and that's all now our own chat message will be added whenever we click on the submit button or even click enter on our keyboard.

//*  This will never explode the page this is highly performant live chat if there are million people on the page who are pushing in comments every millisecond also our page won't freeze .

//* ⁡⁣⁢⁣using real data in live chat feature⁡
//* after implementing the live chat using randomly generated data, we found that some live videos which were streamed few hours ago has no livChatId property, but the videos streaming right now has liveChatId property, so we received the liveChatId as prop in LiveChat component, and also written a liveChatLoad function which will load the chat using liveChatId, but the problem is Some videos which were streamed few hours ago will not have this live chat id and because of that our component will throw an error,Because the data cannot be fetched without the liveChatId, That's why inside our set interval function where we are polling our data there we have written a condition that if the live chat id is present which we received through the prop, Then we'll call our live chat loader function and display the actual data coming from the api but if live chat id is not present because the video was streamed few hours ago then we will display randomly generated live chat using the solution we built few minutes ago so basically the random data we pushed into our Redux store to show the chat data it will be only shown when the live chat id property is not present.see below how we implemented it.

//* ⁡⁣⁢⁣Episode 4 useMemo,useCallBack,useRef hooks⁡

//*  ⁡⁣⁢⁣UseMemo() hook⁡
//* I'm talking about an important hook which can increase performance of your app , you know there is a hook which is useMemo hook(we import it from react) ,which will increase the performance of your app,  ⁡⁣⁢⁣use memo is a react hook that lets you cache the result of calculations between rerenders⁡ ,important thing to note over here two important words cache the results between rerenders ,when I update my state it re-renders if I want to cache some result so that it does,  I call the api if every time my state changes every time my re render happens I do  want somethings to be cached, I don't want react to do all the work once again,what could be the use case why I dont want to do work again,why I don't want to do work again ?yes it can be expensive operation , if the operation is expensive it  will work again and again it will take something ,  but react already optimizes a lot of things

//* Lets create a demo component demo.js we have this demo.js component ok so , and let's add the path pf this /demo in our router configuration, then we will manually just change the path of the url and see the dome page. now inside the demo page we will create a box with a border.
//
// *now basically I want to do some state changes so that we rerender the component again and again to show the memoization I want to do a lot of state changes, so that is why I am taking this example, so what I will do I want
// *   in side this box we will create a input box, and now to keep track of what the user is typing in the input box we will create a state variable , and use that keep track of user input. and we already know when a state variable updates it triggers react reconciliation process. So the whole component will be re rendered every time user add a new input.
//*    if I did a heavy operation here ,what will happen every time a state changes that heavy operation(like finding nth prime of an large number like 543445) will happen  every time my state changes my heavy operation will happen.
// * so what I will do is I can memoize that heavy operation ,that is what we use useMemo() for , I think this is more of theory let's understand using an example,  so heavy operation means calculation heavy which is operation heavy for browsers what could be heavy like calculating square roots or calculating factorial prime yes lets calculate send something like calculating nth prime number,so let us calculate a prime number every time it re renders let us do that first we will find a function from google for calculating the nth prime number then then we will put in to our helper.js file and export it so we can use that function in the Demo.js file. first of all lets calculate a nth prime number, so let's export the function in Demo.js file  let us create a division in this division ,  suppose I am calculating a prime number here right how do I calculate a prime number , what will happen right see if I refresh my page oh it came quickly because it is a very small number like for 12 ,lets type in something whatever I am typing in over here it should calculate the prime number of that number , so basically we are going to get a number from the user using input field and save that value inside a state variable and then show the nth prime number below the input field using the function we imported from the helper.js file, so the function name was findNthPrime(),
// * so if if input a small number like 100 or 231, it will not take so much time to calculate the prime number but if we input a 5 or 6 digit number then surprising we will see the page will freeze, because it is very heavy operation, because behind the scenes it is performing the heavy operation which made the page freeze.
//* and if we have to calculate for a 7-8 digit number then it will become more heavy operation.
//*  So now we will create another state variable named is dark theme and its initial value will be false because by default we don't Want the box color to be change dand now inside the diff container so inside the class name property where we define all of the styles there we can put all of the styles inside curly braces and then after that we will add a + and then write like
/* className={
        "w-96 h-96 border-2 m-4  border-white " +
        (isDarkTheme && "bg-slate-100 text-black")
      }*/

//* So basically above we want to try that if the state variables value is true then only the and operator will be triggered and the styles after the && operator will be applied . And now we will add a button and click off that button we will basically make the state variables value opposite to its current value so basically we want to toggle between the colors that is why we are going to set the state variables value opposite to its current value like:-
//*onClick={() => setIsDarkTheme(!isDarkTheme)}
//* so whenever we click on the button it will toggle the background color.Now if I will write 123 in the input box, the problem is the  if I toggle my theme now it is again rendering because the state variable related to theme changes that means it is calculating the prime number  every time I am changing my theme,but is it required ? 'its not required', to understand the basic problem  suppose if I calculate prime number of 123 , so  it should calculate my prime number, but when I am toggling the theme why am I doing that heavy operation of calculating the prime ? it is not necessary because changing the theme will not change the prime number so  why am I doing that heavy operation on the theme change when it is not necessary,  now when I calculated this prime number of 1234567 it took some time because it is long number , but after calculating it , if we change theme then there is no need to recalculate it, so the usage of useMEmo hook comes which will cache the calculated value of this heavy operation before rerender and after the rerender it won't need to recalculate it.So this kind of issues can be handled using memoization, using useMemo hook.
//*⁡⁣⁢⁣syntax of the useMemo hook⁡
//* ⁡⁣⁢⁣const cachedValue = useMemo(calculateValue, dependencies)⁡
//* ⁡⁢⁣⁣as the first  parameter this hook takes a function(not a function call because the hook will call the function itself) (heavy task performing function we want to cache), and in the cacheValue constant it will cache the value which will be return by the  function, and second parameter is the dependency array. here we mention the dependencies. So that means it will cache value between every rerender except when the dependency array changes .⁡
//* so in the Demo.js example , to cache the value of the nth prime number , we have write like this:-
//*  ⁡⁣⁢⁣ const prime =useMemo( ()=>findNthPrime(text),[text]);⁡
//* ⁡⁢⁣⁣So it will cache/memoize the value between every rerender except the text state variable changes because it is mentioned in the dependency array. So in this way, even our other state variable changes like theme color state variable and that cause the rerender still the value will be cached.it will be only recalculated when text state variable changes.⁡

//*⁡⁣⁢⁣UseCallback Hook⁡
//*   there is one more hook which is useCallback hook.  use memo is cache  the result of calculation between rerenders.but  ⁡⁣⁢⁣useCallback hook helps to cache  a function definition between rerenders ⁡.

//* ⁡⁣⁢⁣UseRef Hook⁡
//* useRef is a react hook that lets you reference a value that's not needed for rendering.
//*   basically  when you would not need to re render ? if there is a case where you want to keep  some data in your component which you don't want to rerender, then you will use useRef hook,
// * Suppose if you want to store some value in a variable and update it, but you don't want the component to re render , you want some value  in a variable in your component but you don't want component to re render , but now we can say that you can use a local variable  so I can use a let variable, let V= 10 , I can use this value , so this is the value I needed in my component but I don't want this component to re render ,but the problem is I can't change my V variable,how will I change this variable's value? using useState,we might have guessed it, but if I use UseState what will happen , it will re-render whenever we change/update it,but  I want to change the value of V but I don't want to re render the component, I want this value 10 to be updated to 11 but I don't want to re-render let me take a good example let us create another demo file name demo2.js

//*  we will export this component and render it beside the previous demo component, so for that we will go to the app.js file and we will render this component beside the previous demo component using a fragment, so it can be opened using the same /demo path,and now we can open this / demo path to see the component.
//* so inside this demo2 component, we will create the let v and it's value will be 10, now inside the component we will display this value and and we will create a button and onClick of this button we will increase v variable's value by 1, and we will print it to the console.and right now we don't have any state variable so we have to console.og it inside the onClick function because when we update the variable's value it will not rerender.
//* Now we will create another state variable named Y and remember that it is a state variable so whenever we will update this state variable it will render the component so in the previous case it was not re rendering so now we will also display this Y variables value on the ui and also create another button which will increase this state variable's value on click of that button so basically it will update the state of this variable.
//* Now we already know that whenever we will click to increase the Y variable it will update the ui with the updated variable value.
//* But now a strange thing gonna happen so now first of all we will increase the variable X's value, Softer clicking 4 or 5 times its value will be printed at 15on the console so that means its value is right now 15but if we click on the Y increasing button we already know that it will display one because its initial value was 0 and now after adding one its value is 1.
//* But now if we again click on X increasing button suddenly we will see that 11 will be printed on the console but it's strange right because previously its value was 15 so now after increasing 1 it should be 16. But it is showing 11.
//*  I am updating the state , the state is doing ?it is re rendering the component, whenever you re render, X variable is refreshed, X is deleted wiped off,why it got wiped off ? because at the end of the day  this component  is a function, what happens when a function is called in javascript? a whole new execution context is created a whole new memory space is created a whole new thread of execution starts in, and that execution context is pushed into the call stack,  So basically after rendering we are getting a new X variable not the previousX variable so that's why we are seeing this kind of behaviour so after rendering X goes back to its initial value.
//* useRef is a React Hook that lets you reference a value that’s not needed for rendering. it is written in the documentation, but let's understand it easily, So whenever rerender happens the value of X resets so the value does not persist between the rendered cycles but using the use ref hook we can do that so the value of X can be persisted between the render cycle if we use this hook ,like state variable
//* Using a useRef hook we can hold/persist a value between rerenders, so the variable don't get reset again like we saw for the normal let used variable.
//*Let's understand using an example, to create a ref variable we have to write like this:- const ref = useRef(initialValue),
//* so using using ref we will also display this this value to our ui, and also increase it using a new button,
// *The returned object by useRef will persist for the full lifetime of the component.
//* But keep in mind that this variable is not a normal variable vso please use rape book does not return a normal value its written object which contains a current property and this current property holds the initial value so that means if we set the initial value to 0 then the object will look like {current:0};so to display this value we have write ref.current nad to increase onClick event we have to write like- ref.current= ref.current=1;

//* So now if we print it using console log and now click on the increasing riff button then in the console we will see that it will be increasing one by one after a click but it will not be displayed on the ui because the ui is not re rendering in this case but let us now click on the Y increasing button and after clicking on it suddenly we will see that the updated value of the rif variable appears surprisingly,So let's say the initial value was 0 and we clicked three times but after clicking three times it was not updated the ui because the ui was not rendered but after we clicked on Y increasing button immediately the render happened and as the useRef hook Persisted the value between the render cycle that's why immediately it printed the actual updated valueof ref variable so if it would be a let variable then it won't happen we already know that.
//* So it is the actual difference between a normal let variable, a state variable and a ref variable so it is like a bit slow but it works well,and I am saying it is slow because it is not immediately updating the ui instead it updates the ui when rerender happens by some other variable and until the rerender happens it does not change the value on the UI.
